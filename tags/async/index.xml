<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>async on Jimmy 's Code</title><link>/tags/async/</link><description>Recent content in async on Jimmy 's Code</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>Copyright © 2022-{year} Jimmy Fang. All Rights Reserved.</copyright><lastBuildDate>Sat, 15 May 2021 15:44:00 +0000</lastBuildDate><atom:link href="/tags/async/index.xml" rel="self" type="application/rss+xml"/><item><title>Go 學習筆記(5): 非同步</title><link>/posts/go-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%985-%E9%9D%9E%E5%90%8C%E6%AD%A5/</link><pubDate>Sat, 15 May 2021 15:44:00 +0000</pubDate><guid>/posts/go-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%985-%E9%9D%9E%E5%90%8C%E6%AD%A5/</guid><description>學習Go 也到了一段時間了，來學習這個部分：多執行緒
如同我之前寫道其實如果要做很大量的東西應該要用非同步的方式&amp;hellip; 在Go裡面，並發被叫做「Goroutine」，在深入淺出Go 這本書的定義：提供並發，暫停一個工作以啟動另一個工作。而且在有些情境下他們允許並行，同時執行不同的工作
如果你想要用goroutine 其實就在function 前面加一個go 的關鍵字
1func main(){ 2 go a() 3 go b() 4} 然而，由於我們使用到這個非同步的概念，所以我們無法期待method 可以馬上回傳結果，那是Go 去控制工作的進行與安排，所以Go裡面便多了一個概念：Channels，其實就加一個chan 這個詞就好
1var myChannel chan float64 2myChannel = make(chan float64) 這時候我們上面得程式可以改寫成這樣
1func a(myChannel chan string){ 2 myChannel &amp;lt;- &amp;#34;a&amp;#34; 3} 4 5func main(){ 6 myChannel := make(chan string) 7 go a(myChannel) 8 fmt.Println(&amp;lt;-myChannel) 9} 但要注意的是，如果我們make 沒有加第二個參數，那麼我們的Channel 就是個無緩衝的channel ，有就意味著我們必須要每次將資料塞進channel 的時候，每一次都要拉出來，否則會造成channel 被鎖定。
那麼，就讓底下示範一下有緩衝的channel 吧
1func a(myChannel chan string){ 2 myChannel &amp;lt;- &amp;#34;a&amp;#34; 3 myChannel &amp;lt;- &amp;#34;b&amp;#34; 4} 5 6func main(){ 7 myChannel := make(chan string,3) 8 go a(myChannel) 9 fmt.</description></item></channel></rss>